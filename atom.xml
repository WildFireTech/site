<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>寂寞先生</title>
 <link href="http://enml.github.io/blog/" rel="self"/>
 <link href="http://enml.github.io/blog"/>
 <updated>2014-08-21T09:46:29+08:00</updated>
 <id>http://enml.github.io/blog</id>
 <author>
   <name>陈佳伟</name>
   <email>blah@email.test</email>
 </author>

 
 <entry>
   <title>canvas总结之图像处理</title>
   <link href="http://enml.github.io/blog/2014/05/24/canvas-image"/>
   <updated>2014-05-24T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/24/canvas-image</id>
   <content type="html">&lt;h1&gt;canvas总结之图像处理&lt;/h1&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>canvas总结之Pixel Manipulation</title>
   <link href="http://enml.github.io/blog/2014/05/24/canvas-Pixel-Manipulation"/>
   <updated>2014-05-24T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/24/canvas-Pixel-Manipulation</id>
   <content type="html">&lt;h1&gt;canvas总结之Pixel Manipulation&lt;/h1&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>canvas总结之动画</title>
   <link href="http://enml.github.io/blog/2014/05/23/canvas_countdown"/>
   <updated>2014-05-23T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/23/canvas_countdown</id>
   <content type="html">&lt;h1&gt;canvas总结之动画&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt; &lt;pre class=&quot;prettyprint linenums&quot;&gt;
        function fallAnimation() {
            for (var i = 0; i &amp;lt; newBall.length; i++) {
                newBall[i].x += newBall[i].Vx;
                newBall[i].y += newBall[i].Vy;
                newBall[i].Vy += newBall[i].a;
                bounces();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            function bounces() {
                //反弹效果
                if (newBall[i].y &amp;gt;= (context.canvas.height - ball.radius)) {
                    newBall[i].y = (context.canvas.height - ball.radius);
                    newBall[i].Vy = -newBall[i].Vy * 0.75;
                }
                //delete the ball outside
                if (newBall[i].x + ball.radius &amp;lt; 0 || newBall[i].x - ball.radius &amp;gt; context.canvas.width) {
                    newBall.splice(i, 1);
                    i--;
                    console.log(newBall.length);
                }
                //停止interval当全部小球已滚出画面
                if (newBall.length == 0) {
                    clearInterval(start);
                }
            }
        }
    }

                    &amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>canvas总结之method</title>
   <link href="http://enml.github.io/blog/2014/05/21/canvas-method"/>
   <updated>2014-05-21T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/21/canvas-method</id>
   <content type="html">&lt;h1&gt;canvas总结之method&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2&gt;canvas介绍&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;canvas&lt;/code&gt;还没出现之前，开发人员通常使用 SVG，VML 等技术进行 Web 绘图操作，但这些基于XML的绘图语言声明式的绘图方式并不能满足复杂绘图操作在性能上的需求，特别是需要像素级别绘图能力的游戏。canvas提供了一系列用于绘图的API,我们可以使用JavaScript脚本语言在canvas中进行一系列基于命令的图形绘制操作。我们的绘图和动画终于可以摆脱第三方插件了，虽然前端的标准问题始终是个大坑。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;canvas id=&quot;canvas&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/code&gt;  这就是canvas，它就是一个html标签，它除了提供一块画布和一系列的API让你可以在javascript中使用之外，看上去什么都没有。但是一块画布和一系列API就等于给了你一张纸和一套画图工具，你可以在上面发挥你的想象，至于画什么以及画的好不好那就是开发者功底的事了。接下来主要是对canvas的API进行分类和总结。&lt;/p&gt;

&lt;h2&gt;canvas的API&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Paths
 跟路径有关的method主要有：&lt;/li&gt;
&lt;li&gt;stroke()：画边框&lt;/li&gt;
&lt;li&gt;fill()：填充&lt;/li&gt;
&lt;li&gt;beginPath()：表示路径的开始&lt;/li&gt;
&lt;li&gt;closePath()：路径结束&lt;/li&gt;
&lt;li&gt;moveTo()：确定起点&lt;/li&gt;
&lt;li&gt;lineTo()：画直线&lt;/li&gt;
&lt;li&gt;arc()：画弧线，当然也能画圆&lt;/li&gt;
&lt;li&gt;rect()：画矩形&lt;/li&gt;
&lt;li&gt;bezierCurveTo()：贝塞尔曲线&lt;/li&gt;
&lt;li&gt;quadraticCurverTo()：二次方程曲线&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;我们通过下面的代码来看看实际效果。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
    var canvas = document.getElementById(&quot;canvas&quot;),
        context = canvas.getContext(&quot;2d&quot;);
    context.beginPath();
    context.moveTo(20,20);
    context.lineTo(200,240);
    context.stroke();
    context.closePath();
&lt;/pre&gt;


&lt;p&gt;这是最简单的画线条方法，用moveTo()确定起点，再用lineTo()画线。有了线段我们可以干嘛？最直观的我们可以画几何图形，比如说三角形，矩形。当我们逻辑能力再强点，想象力再丰富点的时候，线段可以画出令人惊叹的画面。比如说下面的树，就是使用最简单的线段通过递归不断叠加画出来，因为通过random()函数对角度进行随机计算，因此你每一次刷新树的形状都会变化。&lt;/p&gt;

&lt;p&gt;2.style
    我们画出几何图形后，一切都是黑白的。这个时候需要的就是style相关的属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fillStyle：填充颜色&lt;/li&gt;
&lt;li&gt;strokeStyle：边框颜色&lt;/li&gt;
&lt;li&gt;shadowColor：阴影颜色&lt;/li&gt;
&lt;li&gt;shadowBlur：阴影虚化范围&lt;/li&gt;
&lt;li&gt;shadowOffsetX：阴影x轴偏移量&lt;/li&gt;
&lt;li&gt;shadowOffsetY：阴影y轴偏移量&lt;/li&gt;
&lt;/ul&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
context.shadowBlur=10; 
context.shadowOffsetX=20; 
context.shadowColor=&quot;black&quot;; 
context.fillStyle=&quot;red&quot;; 
context.fillRect(20,20,100,80);
&lt;/pre&gt;


&lt;p&gt;上面代码为矩形添加了黑色的阴影，阴影在x轴正方向偏移20px，阴影的虚化范围是10px。这几个canvas的style属性可以为图像添加漂亮的视觉效果，你的图像不再是水墨画，而是多彩多姿的水彩画。&lt;/p&gt;

&lt;p&gt;3.transition&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scale()：按比例放大缩小&lt;/li&gt;
&lt;li&gt;rotate()：旋转&lt;/li&gt;
&lt;li&gt;translate()：平移，会在原来的基础上平移&lt;/li&gt;
&lt;li&gt;transform()：变形&lt;/li&gt;
&lt;li&gt;setTransform()：重置原来的变形执行新的变形&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过transition的相关方法，我们可以把简单的几何图形旋转变形，因此我们不必为了要画另一个只需改变角度的新图形而从头开始，因为这样重复了大量的代码，不但耗时耗力，而且对于代码维护和性能优化都是一个隐患。这些method也可以使动画变得更简单。&lt;/p&gt;

&lt;p&gt;4.pixel manipulation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;createImageData()&lt;/li&gt;
&lt;li&gt;getImageData()&lt;/li&gt;
&lt;li&gt;putImageData()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这三个方法是从像素层次对图像进行操作，看上去很简单，但事实上功能很强大。我们可以获取图像的每一个像素，然后对像素进行操作，比如改变像素的rgb值，从而使整张图片得到完全不同的视觉效果，比如说对像素rgb值进行取反操作已实现整张图像反转滤镜效果。&lt;/p&gt;

&lt;p&gt;总结，今天介绍了canvas的主要绘图方法，这些方法基础功能很简单，但能实现极其惊艳的效果，具体就看自己能否把它用活。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>收藏颜色</title>
   <link href="http://enml.github.io/blog/2014/05/20/collect_color"/>
   <updated>2014-05-20T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/20/collect_color</id>
   <content type="html">&lt;h1&gt;收藏颜色的工具&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://enml.github.io/blog/image/collect_color.jpg&quot; alt=&quot;collect_color&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用了三个小时完成了上图的功能，满足了我的需求。&lt;/p&gt;

&lt;p&gt;只要在输入框输入颜色数值，便可记录到数据库，并把颜色作为该数值背景色输出页面。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;本来是在寻找一个可以保存自己喜欢的颜色的工具，一开始想着记录在onenote，但是只能记录数值，不够直观。如果把图片粘贴过去会很繁琐并且不够雅观。后来把颜色直接合并在一张图上，但记录时每次都需要进行图片修改，繁琐也依然不美观。中午午睡后百度了一下是否有相关的在线工具，一无所获。突然想着要不自己搞一个吧！在脑海里构建了一下基本框架后觉得可行，便开始编写代码。花了三个小时总算实现了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HTTP协议的简析</title>
   <link href="http://enml.github.io/blog/2014/05/20/HTTP"/>
   <updated>2014-05-20T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/20/HTTP</id>
   <content type="html">&lt;h1&gt;HTTP协议的简析&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;HTTP协议是一种可靠的数据传输协议，位于应用层，在TCP协议的上层。我们现在使用的web服务几乎都是建立在HTTP协议之上，HTTP是互联网通信的公共语言。&lt;/p&gt;

&lt;p&gt;从宏观角度来看，HTTP连接是一个很简单的过程，客户端发起请求，服务端相应响应的数据，断开连接。这就是一个完整的连接过程，我们每天上网都在经历这个过程，当你访问一个url时，浏览器会把这个url进行解析，通过dns获取域名对应的IP地址，然后向这个IP地址发送一个HTTP请求，告诉服务器我需要什么数据，服务器处理这个HTTP请求后调用对应的资源，给客户端一个HTTP响应，这个响应中就包含了我们请求的资源。&lt;/p&gt;

&lt;p&gt;上图是一个完整的HTTP连接过程。一般情况下请求中会包含3部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;start line(上图中的GET /something/some.gif HTTP/1.1)&lt;/li&gt;
&lt;li&gt;request header（键值对，比如Accept:text.*,用来告诉服务器我要接受的数据的格式是text）&lt;/li&gt;
&lt;li&gt;request body（get方法一般body为空，post方法会把提交给服务器的数据写在request body中）.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;同样服务器的respose中也会包含这三部分，但是内容不同。这里就不讲了。我们来讲数据的传输。&lt;/p&gt;

&lt;p&gt;HTTP是在应用层把我们的请求以及服务器的响应转化为&lt;code&gt;messages&lt;/code&gt;(报文)发送给传输层的TCP协议进行传输，也就是说，HTTP事实上并不关心数据的传输过程，数据传输依赖的是极为可靠的TCP协议。说到TCP，我们就不得不说&lt;code&gt;三次握手&lt;/code&gt;。TCP为了确保连接的可靠性，建立连接时必须遵循严格的三次握手确认才能连接成功。下图是示意图：&lt;/p&gt;

&lt;p&gt;我尽可能用通俗的语言来讲解这个过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一次握手：client把自己的身份证（SYN）发给server，告诉server说我要跟你连接。&lt;/li&gt;
&lt;li&gt;第二次握手：server知道client想跟他连接后，就在收到的client的身份证上盖个章（ACK=SYN+1），然后把server自己的身份证(新的SYN)+盖了章的身份证一起发回给client，告诉他我同意你的连接请求。&lt;/li&gt;
&lt;li&gt;第三次握手：client看到自己的身份证已经盖了章，就相信这个请求确实是来自server并且server同意连接，所以client也在server的身份证上盖个章（新ACK=新SYN+1）发回给server。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;server收到自己的盖了章的身份证后就跟client建立连接，发送数据。现在的TCP栈都运行客户端在第三次握手时直接把&lt;code&gt;messages&lt;/code&gt;发送给服务器。为什么要三次握手，而不是两次呢？据我目前的理解，三次握手是已最低的代价来保证数据传输的可靠性。我们假设只有两次握手即可建立连接发送数据，那么如果在第二次握手的过程中确认包丢失，client端收不到server的确认包，那么client会认为他们之间还不能建立连接，而server并不知道确认包丢失了，以为我已经确认了我们就可以建立连接，所以此时server就会跟client进行通信，但client肯定会拒收，server就一直重发数据，造成了一个死结。而很明显，三次握手就不会出现这种不可靠的情况，四次握手就更可靠了，但浪费资源。&lt;/p&gt;

&lt;p&gt;说完TCP建立连接的过程，我们再回过头来看一看HTTP报文是怎么传输的。下图所示&lt;/p&gt;

&lt;p&gt;这是报文传输的过程，浏览器解析用户请求==&gt;生成HTTP请求报文==&gt;TCP三次握手跟服务器建立连接==&gt;传送报文给服务器==&gt;服务器处理报文请求，生成HTTP响应报文==&gt;传送报文给客户端==&gt;断开连接。&lt;/p&gt;

&lt;p&gt;我们对HTTP请求已经数据传输的过程有了大概的了解之后，我们再来谈谈一些HTTP报文的细节，关于状态码、请求方法。&lt;/p&gt;

&lt;h3&gt;状态码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;100-199 ：信息提示&lt;/li&gt;
&lt;li&gt;200-299：成功&lt;/li&gt;
&lt;li&gt;300-399：重定向&lt;/li&gt;
&lt;li&gt;400-499：客户端错误&lt;/li&gt;
&lt;li&gt;500-599：服务器错误&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其中我们挑出几个常用的具有代表性的说一下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;100 continue&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这是一个比较让人疑惑的状态码。它向服务器发送一个携带了值为100 continue的expect请求，服务器收到后响应一个100 continue状态码或者错误码。这看上去很多余，但事实上，的确有那么点多余，但是它有一个作用就是在发送实体之前先确认服务器是否接受这个实体，避免发送了一个服务器无法处理或使用的实体。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;200 ok&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这个最常见，你每一个成功的请求都会收到200 ok的状态码，告诉浏览器请求成功。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;304 no modified&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以在请求里添加If-Modefied-Since:xxx的首部，服务器对请求资源进行检验后若确定在该时间内资源未被改动，则可以返回304 no modefied进行资源重定向，让浏览器直接使用本地副本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;404 not found&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当服务器无法找到你所请求的资源，可能资源已不存在，可能客户端的请求有错误，这时候会返回404 not found，这个几乎每个上网的用户都会遇到。&lt;/p&gt;

&lt;p&gt;上面是比较常见的状态码的含义。在HTTP报文里面，状态码是一种很重要的信息，为客户端提供了一种理解事务处理结果的便捷方式。&lt;/p&gt;

&lt;p&gt;下一篇文章会归纳关于HTTP报文通过TCP/IP底层协议进行传输的性能问题。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Template</title>
   <link href="http://enml.github.io/blog/2014/05/10/template"/>
   <updated>2014-05-10T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/10/template</id>
   <content type="html">&lt;h1&gt;Template&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;在view里面，我们获取了相关的数据，但我们的目的是将数据呈现出来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.首先我们想到的是直接把数据硬编码到html代码里面，然后通过&lt;code&gt;HttpResponse&lt;/code&gt;对象传递给浏览器进行渲染：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % now
    return HttpResponse(html)
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;但是很明显这种方法不适合生产环境，你不可能把整个html页面都硬编码在view里面，因为这显得既愚蠢又低效。对于template的改动很明显要比view频繁得多，这种方式意味着你想更改页面表现时都必须得改动python代码，并且前后端无法同步开发。于是有了第二种方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.把html代码分离成独立的模板，通过加载模板文件进行渲染，这样可以实现前后端分离：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;   #view
from django.shortcuts import render_to_response
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response(&#39;current_datetime.html&#39;, {&#39;current_date&#39;: now})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#template
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now .&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过render()传递数据给template的方式在上一篇文章有列举出来。这种模式的好处很明显。但我们又遇到一个问题：&lt;strong&gt;假如我的网站有100个页面，那我是不是要写100个template呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道这样是愚蠢。编程中有一个很重要的思想就是--&lt;strong&gt;最大限度地实现代码重用。&lt;/strong&gt; 而我们写100个页面的重复代码可能已经超过40%了，这不但费时费力，你还可能见笑于大方之家。所以我们有一种优雅的解决方式：&lt;strong&gt;include&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1). 把重用代码分离出来，比如header.html,footer.html,sidebar.html；然后&lt;code&gt;include&lt;/code&gt;到content.html中。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# header.html

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # footer.html

        &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# include &#39;header&#39; and &#39;footer&#39;

{ include &#39;header.html&#39; %}
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
{ include &#39;footer.html&#39; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，这样很优雅，可以实现代码重用。但是仍然有个问题：当代码中存在哪怕一个标记不同时，这部分代码你就无法分离出来，这导致了你仍然需要重复大量的代码。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# first page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# second page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Future time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个页面中&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;不同，意味着&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;以下的部分都不能并入&lt;code&gt;header.html&lt;/code&gt;中，哪怕下面仍然存在大量的重复代码。所以有了更优雅的解决办法：&lt;strong&gt;extends&lt;/strong&gt; -- inculde的逆向思维。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2). 我们把模板里面的‘不同代码’进行定义，相同的代码保存为base模板&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{ block title %}{ endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    { block content %}{ endblock %}
    { block footer %}
    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    { endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;base.html&lt;/code&gt;变成了一个骨架，你可以把需要的内容填充进去即可，这最大限度实现了代码重用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # first page

    { extends &quot;base.html&quot; %}

    { block title %}The current time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # second page

    { extends &quot;base.html&quot; %}

    { block title %}Future time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;woo! 简单优雅！这是Template设计的思想历程。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>view传递context的方式</title>
   <link href="http://enml.github.io/blog/2014/05/03/view_render"/>
   <updated>2014-05-03T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/05/03/view_render</id>
   <content type="html">&lt;h1&gt;view传递context的方式&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt; 通过view的render()方法填充template可以有以下方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.适合于数据量小且静态的数据。在template中直接使用相关键值为标签：
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test1(request):
    return render(request,&#39;test/raw.htm&#39;,{
                &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False})
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;2.通过调用属性的方式传递整个dictionary。但在template中必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test2():
    person = {  &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,{ &#39;person&#39;:person, &#39;dict&#39;:dict})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.使用&lt;strong&gt;locals(),locals()&lt;/strong&gt; 是个字典，直接赋值给变量。很明显这种方式更加优雅和便捷，但缺点就是它会把所有的dictionary都传递，也就是说它默认传递的值可能会比你预想中的多。&lt;/p&gt;

&lt;p&gt;   template中仍然必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test3():
    person = {  &#39;name&#39;: &#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,locals())
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>install jekyll 流程</title>
   <link href="http://enml.github.io/blog/2014/04/27/install-jekyll"/>
   <updated>2014-04-27T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/04/27/install-jekyll</id>
   <content type="html">&lt;h1&gt;install jekyll 流程&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载&lt;code&gt;ruby&lt;/code&gt;&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;安装ruby download&lt;/a&gt; ，然后下载&lt;strong&gt;DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe&lt;/strong&gt;。安装完&lt;code&gt;ruby&lt;/code&gt;后，再安装&lt;code&gt;rubyGems&lt;/code&gt;:运行&lt;code&gt;gem update --system&lt;/code&gt;即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压DevKit，然后命令行cd到该目录，运行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;pre&gt;&lt;code&gt; ruby dk.rb init
 ruby dk.rb review 
 ruby dk.rb install
 gem install rdiscount --platform=ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DevKit安装完后，即可安装jekyll：&lt;code&gt;gem install jekyll&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>python list的技巧</title>
   <link href="http://enml.github.io/blog/2014/04/25/python-code"/>
   <updated>2014-04-25T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/04/25/python-code</id>
   <content type="html">&lt;h1&gt;Python list的一些技巧&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;列表相邻元素压缩器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; zip(*([iter(a)] * 2))
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::2], a[1::2])
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::3], a[1::3], a[2::3])
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*(a[i::k] for i in range(k)))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;用压缩器反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m.items()
[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]
&amp;gt;&amp;gt;&amp;gt; zip(m.values(), m.keys())
[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]
&amp;gt;&amp;gt;&amp;gt; mi = dict(zip(m.values(), m.keys()))
&amp;gt;&amp;gt;&amp;gt; mi
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表展开&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2], [3, 4], [5, 6]]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain.from_iterable(a))
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; sum(a, [])
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; [x for l in a for x in l]
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; [x for l1 in a for l2 in l1 for x in l2]
[1, 2, 3, 4, 5, 6, 7, 8]

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
&amp;gt;&amp;gt;&amp;gt; flatten(a)
[1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;生成器表达式&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g = (x ** 2 for x in xrange(10))
&amp;gt;&amp;gt;&amp;gt; next(g)
0
&amp;gt;&amp;gt;&amp;gt; next(g)
1
&amp;gt;&amp;gt;&amp;gt; next(g)
4
&amp;gt;&amp;gt;&amp;gt; next(g)
9
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10))
2025
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)
408
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;字典推导&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {x: x ** 2 for x in range(5)}
&amp;gt;&amp;gt;&amp;gt; m
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; m = {x: &#39;A&#39; + str(x) for x in range(10)}
&amp;gt;&amp;gt;&amp;gt; m
{0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用字典推导反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m
{&#39;d&#39;: 4, &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&amp;gt;&amp;gt;&amp;gt; {v: k for k, v in m.items()}
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Point = collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p
Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p.x
1.0
&amp;gt;&amp;gt;&amp;gt; p.y
2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;继承命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Point(collections.namedtuple(&#39;PointBase&#39;, [&#39;x&#39;, &#39;y&#39;])):
...     __slots__ = ()
...     def __add__(self, other):
...             return Point(x=self.x + other.x, y=self.y + other.y)
...
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; q = Point(x=2.0, y=3.0)
&amp;gt;&amp;gt;&amp;gt; p + q
Point(x=3.0, y=5.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有最大长度的双端队列&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; last_three = collections.deque(maxlen=3)
&amp;gt;&amp;gt;&amp;gt; for i in xrange(10):
...     last_three.append(i)
...     print &#39;, &#39;.join(str(x) for x in last_three)
...
0
0, 1
0, 1, 2
1, 2, 3
2, 3, 4
3, 4, 5
4, 5, 6
5, 6, 7
6, 7, 8
7, 8, 9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可排序词典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = dict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
1, 0, 3, 2, 5, 4, 7, 6, 9, 8
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
10, 9, 8, 7, 6, 5, 4, 3, 2, 1
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>jekyll加载图片的路径问题</title>
   <link href="http://enml.github.io/blog/2014/04/24/directory"/>
   <updated>2014-04-24T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/04/24/directory</id>
   <content type="html">&lt;h1&gt;jekyll加载图片的路径问题&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　一开始使用根目录&lt;code&gt;/assets/…/img/bg.png&lt;/code&gt;的方式，在localhost调试成功，但在github pages失败。
　后来试了一下当前目录方式&lt;code&gt;./img/bg.png&lt;/code&gt;成功。也可以用&lt;code&gt;img/bg.png&lt;/code&gt;表示当前目录。&lt;/p&gt;

&lt;!--break--&gt;

</content>
 </entry>
 
 <entry>
   <title>对5天来关于jekyll的心得</title>
   <link href="http://enml.github.io/blog/2014/04/23/finish-jekyll"/>
   <updated>2014-04-23T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/04/23/finish-jekyll</id>
   <content type="html">&lt;h1&gt;完成基于jekyll的第一个blog&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　今天差不多把blog完成了，这是我第一个基于jekyll的blog，定制了主题，修改了相关配置，以及解决了中文bug。现在把这5天的心得分享一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先是中文问题，这个困扰我了很久，也花费了不少时间，不过最后总算找到解决办法。给我最大的感触就是，即使碰壁，也得硬着头皮找下去，如果放弃，那就前功尽弃了。&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后是关于bootstrap，因为主题是基于bootstrap，所以这几天对bootstrap也有了深入的了解。Less预编译的思想其实挺方便的，只不过先前习惯了直接div+css的方式后一时难以习惯，但是，习惯是用来打破，不打破那永远都进不了步。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@media通过检测min-width和max-width来进行响应式布局，但要编写全局css时要注意，否则很容易响应不了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\&lt;hr&gt; 添加个具有margin的hr，然后在使用card style时可以通过添加hr来达到分割的效果。另一种方式是直接为card添加一个margin-top。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当我使用中文的categories时，由于permalink中包含categories，导致链接失败。所以只要到_config.yml中修改permalink即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>解决invalid byte sequence in GBK</title>
   <link href="http://enml.github.io/blog/2014/04/23/chinese-messy-code"/>
   <updated>2014-04-23T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/04/23/chinese-messy-code</id>
   <content type="html">&lt;h1&gt;解决invalid byte sequence in GBK&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　jekyll对中文的支持不太好，导致经常出现乱码甚至无法运行&lt;code&gt;jekyll server&lt;/code&gt;命令。解决post内容乱码问题可以通过修改convertible.rb文件的第27行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name), :encoding =&amp;gt; &quot;utf-8&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　原因File.read()可能采用系统默认编码读取文件，中文系统为GBK，但markdown文件均为utf-8编码，所以导致无法正确展现中文。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　但是当我在post.html模板里面加入中文之后，&lt;code&gt;jekyll server&lt;/code&gt;命令直接报错。解决办法是在运行服务器前先运行&lt;code&gt;chcp 65001&lt;/code&gt;命令，即可解决。在官方找到的解决办法&lt;strong&gt;Windows users: run chcp 65001 first to change the command prompt&#39;s character encoding (code page) to UTF-8 so Jekyll runs without errors.&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>后智能手机时代</title>
   <link href="http://enml.github.io/blog/2014/04/21/future"/>
   <updated>2014-04-21T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2014/04/21/future</id>
   <content type="html">&lt;h1&gt;谁将取代智能手机&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wccbr.com/wp-content/uploads/2013/03/Robot_Wallpaper_1.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能手表&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　现在手表被炒的很热，但以目前来看，手表只是一个辅佐设备；注定手表不可能超越智能手机。手表的特点在于屏幕小，便携，查看信息快速直接；但屏幕小也是它的极限性（屏幕扩大了跟智能手机就没差别了），决定了它不适合发展成独立的终端，你能想象拿着手表刷微博看知乎发邮件吗？&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　除非发展出了超越平面显示的信息展现方式，比如说已经被说烂了的“全息投影”。否则手表永远只能是手机的辅佐设备。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能眼镜&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这货一开始我不看好，谁tm想戴个电池cpu在太阳穴那里，而且带了几年眼镜的我表示对眼镜深痛恶绝啊。后来了解了google glass之后，我发现这货绝对是未来。不，我是说这个方向。&lt;/p&gt;

&lt;p&gt;　为什么智能眼镜有潜力取代智能手机呢？首先，我们从电子设备的发展历程可以看出，任何具有划时代的产品都是通过对人机交互方式进行革新。从命令行跨越到图形界面，从物理按键跨越到触摸，从遥控器跨越到体感声控……再看看手表，再怎么有想象力它始终只是一部小尺寸精简化的手机绑在手上，不管是现在市面上丑陋不堪的炒作产品，还是被寄予厚望的iwatch，都难以在信息展现方式上得到突破；再看看眼镜，信息是直接投射到视网膜上，信息展现方式已经不再局限于屏幕的大小，你眼前的整个视角都是屏幕，甚至可以通过调节投射的焦距而达到调节屏幕的大小，那可想像的空间可就大了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为展现信息独特的视角，眼镜可以覆盖你的整个视角，它可以挡住外来的光线让你完全沉浸在数字光影之中；你可以随时随地享受不亚于甚至超越IMAX的视觉盛宴。是的，我说的不是3D眼镜。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为现实与虚拟的无缝结合，你去超市或者在复杂的商业街寻找餐馆，你不用再打开地图或者大众点评，你眼前就是信息与现实的结合体；如果你用过nokia的city lens，你一定知道我在说什么。你不用再厚着脸皮去找心仪的妹子要联系方式了，只要她在社交网络公开信息，你盯着她看几秒可能就已经加了她的微信或者facebook了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为“所见即所得”，你所能看到的美景都可以收入囊中，不会再因为掏出手机解锁打开相机应用而错过稍众即逝的美景。当然，google glass现在因为这个产生的隐私问题而备受争议。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;……还有很大的想象空间，只是我想不出来了。但是如果做到以上3点，你完全可以抛弃你的智能机了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　以上，并不是空穴来风的天方夜谭，不信，你试着在手表上想象一下。这些是基于信息展现方式，或者说是交互方式的革新。google glass目前并不足以产生颠覆性，产品还不完善，技术也难以突破，生态更是一片荒芜，但它叩开了一个全新世界的大门，这个大门后面的世界才是未来。说实话，我更期待苹果和微软在这方面的突破。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;机器人&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这条路任重而道远，真的要发展出人工智能的话，很可能要对现有的计算机体系、软硬架构、甚至编程思想统统进行颠覆才有可能。但是，100年后每个人身边陪着个高度智能的机器人作助手甚至伴侣应该没什么好争议的。那时候什么手机电脑手表眼镜通通可以扔掉了，人可以真正得到解放，这个随时随地跟着你的机器人就是你最好最强大的电子设备了。你要打电话，你就跟它说帮我call一下奥巴马；你要玩游戏，它转过身来可能后背就是一块触摸屏；你要写代码，哦，那时候应该不用写代码了……&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript——闭包</title>
   <link href="http://enml.github.io/blog/2013/06/14/js-closesure"/>
   <updated>2013-06-14T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2013/06/14/js-closesure</id>
   <content type="html">&lt;h1&gt;javascript——闭包&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3&gt;闭包&lt;/h3&gt;


&lt;p&gt;官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点：
    &lt;br&gt;　　1.作为一个函数变量的一个引用，当函数返回时，其处于激活状态。
    &lt;br&gt;　　2.一个闭包就是当一个函数返回时，一个没有释放资源的栈区。
&lt;/p&gt;


&lt;p&gt;我们来看下面的例子：&lt;/p&gt;




&lt;pre&gt; 
   function closure(){
        var name = &quot;enm&quot;;
        return {
            getStr:function(){
                return name;
            }
        }
    }
    var builder = new closure();
    builder.name;//undefined
    name;//undefined,这里是访问不了function的私有变量的
    console.log(builder.getStr()); //返回了enm
 &lt;/pre&gt;




&lt;p&gt;上面构造了一个闭包，这个闭包都维持着对外部作用域的引用，因此不管在哪调用总是能够访问函数中的变量。在一个函数内部定义的函数，会将外部函数的活跃对象添加到自己的作用域链中，因此上面实例中通过内部函数能够访问外部函数的属性，这也是javascript模拟私有变量的一种方式。
&lt;/p&gt;


&lt;h3&gt;闭包经典问题&lt;/h3&gt;


&lt;p&gt;我们来看看下面经典的例子：&lt;/p&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;   function timeManage() {
        for (var i = 0; i &amp;lt; 5; i++) {
            setTimeout(function() {
                console.log(i);
            },1000)
        };
    }

&lt;/pre&gt;


&lt;p&gt;上面的程序并没有按照我们预期的输入1-5的数字，而是5次全部输出了5。再来看一个示例：&lt;/p&gt;

&lt;pre&gt;
    
function createClosure(){
    var result = [];
    for (var i = 0; i &amp;lt; 5; i++) {
        result[i] = function(){
            return i;
        }
    }
    return result;
}
&lt;/pre&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;调用createClosure()[0]()返回的是5，createClosure()[4]()返回值仍然是5。原因我们最后再说，因为现在我自己的理解跟网上其他人的理解有出入。我们先来看看怎么解决。我们可以通过&lt;code&gt;匿名自执行函数表达式&lt;/code&gt;来强制返回预期的结果：&lt;/p&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt; function timeManage() {
    for (var i = 0; i &amp;lt; 5; i++) {
        (function(num) {
            setTimeout(function() {
                console.log(num);
            }, 1000);
        })(i);
    }
}
 &lt;/pre&gt;




&lt;p&gt;或者在闭包匿名函数中再返回一个匿名函数赋值：&lt;/p&gt;




&lt;pre&gt; function timeManage() {
    for (var i = 0; i &amp;lt; 10; i++) {
        setTimeout((function(e) {
            return function() {
                console.log(e);
            }
        })(i), 1000)
    }
}
//timeManager();输出1,2,3,4，5
function createClosure() {
    var result = [];
    for (var i = 0; i &amp;lt; 5; i++) {
        result[i] = function(num) {
            return function() {
                console.log(num);
            }
        }(i);
    }
    return result;
}
//createClosure()[1]()输出1；createClosure()[2]()输出2
 &lt;/pre&gt;


&lt;p&gt;我再尝试另一种方法：&lt;/p&gt;


&lt;pre&gt;
      function timeManage() {
          function foo() {
                console.log(i);
            }
        for (var i = 0; i &lt; 5; i++) {
           foo()
        };
    }
    timeManage();//输出1，2，3，4，5
 &lt;/pre&gt;


&lt;p&gt;无论是匿名包裹器还是通过嵌套匿名函数的方式，原理上都是将变量i的值复制给实参num，在匿名函数的内部又创建了一个用于返回num的匿名函数，这样每个函数都有了一个num的副本，互不影响了。而第三种方法是先定义函数，然后在for循环中直接调用函数，这也是一个闭包，也依然保持对外部变量i的访问，但是不会出现我们说的问题&lt;/p&gt;


&lt;p&gt;所以，有人解释解释出现这个问题的原因是&lt;b&gt;由于作用域链机制的影响，闭包只能取得内部函数的最后一个值&lt;/b&gt;,这样说没有错，因为你执行完循环再调用函数，函数引用同一个i，那么结果肯定是最后修改的值5。但这样解释会让这个问题变得迷糊，因为其实本质上这个例子是通过setTimeout函数故意延迟了函数的执行，通过我第三种解决方法可以看出，假如每一次循环都能立即执行函数，那么是完全可以输出每一个i的正确值的。也就是说，其实这个问题的容易让人迷糊的原因是函数没有立即执行，而不能说是闭包产生的结果。&lt;/p&gt;


&lt;h3&gt;闭包中的this&lt;/h3&gt;


&lt;p&gt;闭包中的this 在闭包中使用this时要特别注意，稍微不慎可能会引起问题。通常我们理解this对象是运行时基于函数绑定的，全局函数中this对象就是window对象，而当函数作为对象中的一个方法调用时，this等于这个对象（TODO 关于this做一次整理）。由于匿名函数的作用域是全局性的，因此闭包的this通常指向全局对象window：&lt;/p&gt;


&lt;pre&gt;
var scope = &quot;global&quot;;
var object = {
    scope:&quot;local&quot;,
    getScope:function(){
        return function(){
            return this.scope;
        }
    }
}
&lt;/pre&gt;




&lt;p&gt;调用object.getScope()()返回值为global而不是我们预期的local，前面我们说过闭包中内部匿名函数会携带外部函数的作用域，那为什么没有取得外部函数的this呢？每个函数在被调用时，都会自动创建this和arguments，内部匿名函数在查找时，搜索到活跃对象中存在我们想要的变量，因此停止向外部函数中的查找，也就永远不可能直接访问外部函数中的变量了。总之，在闭包中函数作为某个对象的方法调用时，要特别注意，该方法内部匿名函数的this指向的是全局变量。 幸运的是我们可以很简单的解决这个问题，只需要把外部函数作用域的this存放到一个闭包能访问的变量里面即可：
&lt;/p&gt;




&lt;pre&gt; var scope = &quot;global&quot;;
var object = {
    scope:&quot;local&quot;,
    getScope:function(){
        var that = this;
        return function(){
            return that.scope;
        }
    }
}
 &lt;/pre&gt;




&lt;p&gt;object.getScope()()返回值为local。&lt;/p&gt;




&lt;p&gt;内存与性能 由于闭包中包含与函数运行期上下文相同的作用域链引用，因此，会产生一定的负面作用，当函数中活跃对象和运行期上下文销毁时，由于必要仍存在对活跃对象的引用，导致活跃对象无法销毁，这意味着闭包比普通函数占用更多的内存空间，在IE浏览器下还可能会导致内存泄漏的问题，如下：
&lt;/p&gt;




&lt;pre&gt;  function bindEvent(){
    var target = document.getElementById(&quot;elem&quot;);
    target.onclick = function(){
        console.log(target.name);
    }
 }
 &lt;/pre&gt;




&lt;p&gt;上面例子中匿名函数对外部对象target产生一个引用，只要是匿名函数存在，这个引用就不会消失，外部函数的target对象也不会被销毁，这就产生了一个循环引用。解决方案是通过创建target.name副本减少对外部变量的循环引用以及手动重置对象：&lt;/p&gt;




&lt;pre&gt;   function bindEvent(){
    var target = document.getElementById(&quot;elem&quot;);
    var name = target.name;
    target.onclick = function(){
        console.log(name);
    }
    target = null;
 }
 &lt;/pre&gt;




&lt;p&gt;闭包中如果存在对外部变量的访问，无疑增加了标识符的查找路径，在一定的情况下，这也会造成性能方面的损失。解决此类问题的办法我们前面也曾提到过：尽量将外部变量存入到局部变量中，减少作用域链的查找长度。&lt;/p&gt;




&lt;p&gt;总结：闭包不是javascript独有的特性，但是在javascript中有其独特的表现形式，使用闭包我们可以在javascript中定义一些私有变量，甚至模仿出块级作用域，但闭包在使用过程中，存在的问题我们也需要了解，这样才能避免不必要问题的出现。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>javascript——作用域</title>
   <link href="http://enml.github.io/blog/2013/06/12/js-scope"/>
   <updated>2013-06-12T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2013/06/12/js-scope</id>
   <content type="html">&lt;h1&gt;javascript——作用域&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;作用域和作用域链是javascript中非常重要的特性，对于他们的理解直接关系到对于整个javascript体系的理解，而闭包又是对作用域的延伸，也是在实际开发中经常使用的一个特性，实际上，不仅仅是javascript，在很多语言中都提供了闭包的特性。
作用域&lt;/p&gt;

&lt;p&gt;作用域是一个变量和函数的作用范围，javascript中函数内声明的所有变量在函数体内始终是可见的，在javascript中有全局作用域和局部作用域，但是没有块级作用域，局部变量的优先级高于全局变量，通过几个示例来了解下javascript中作用域的那些“潜规则”（这些也是在前端面试中经常问到的问题）。
1. 变量声明提前
示例1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scope=&quot;global&quot;;
function scopeTest(){
    console.log(scope);
    var scope=&quot;local&quot;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scopeTest(); //undefined
此处的输出是undefined，并没有报错，这是因为在前面我们提到的函数内的声明在函数体内始终可见，上面的函数等效于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scope=&quot;global&quot;;
function scopeTest(){
    var scope;
    console.log(scope);
    scope=&quot;local&quot;  
}
scopeTest(); //local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，如果忘记var，那么变量就被声明为全局变量了。
2. 没有块级作用域
和其他我们常用的语言不同，在Javascript中没有块级作用域：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function scopeTest() {
    var scope = {};
    if (scope instanceof Object) {
        var j = 1;
        for (var i = 0; i &amp;lt; 10; i++) {
            //console.log(i);
        }
        console.log(i); //输出10
    }
    console.log(j);//输出1

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在javascript中变量的作用范围是函数级的，即在函数中所有的变量在整个函数中都有定义，这也带来了一些我们稍不注意就会碰到的“潜规则”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scope = &quot;hello&quot;;
function scopeTest() {
    console.log(scope);//①
    var scope = &quot;no&quot;;
    console.log(scope);//②
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在①处输出的值竟然是undefined，简直丧心病狂啊，我们已经定义了全局变量的值啊，这地方不应该为hello吗？其实，上面的代码等效于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scope = &quot;hello&quot;;
function scopeTest() {
    var scope;
    console.log(scope);//①
    scope = &quot;no&quot;;
    console.log(scope);//②
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;声明提前、全局变量优先级低于局部变量，根据这两条规则就不难理解为什么输出undefined了。&lt;/p&gt;

&lt;h3&gt;作用域链&lt;/h3&gt;

&lt;p&gt;在javascript中，每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。
作用域链的前端是当前代码执行环境的变量对象，常被称之为“活跃对象”，变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中：&lt;/p&gt;

&lt;p&gt;作用域链的逐级查找，也会影响到程序的性能，变量作用域链越长对性能影响越大，这也是我们尽量避免使用全局变量的一个主要原因。&lt;/p&gt;

&lt;h3&gt;闭包&lt;/h3&gt;

&lt;p&gt;基础概念
作用域是理解闭包的一个前提，闭包是指在当前作用域内总是能访问外部作用域中的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function createClosure(){
    var name = &quot;jack&quot;;
    return {
        setStr:function(){
            name = &quot;rose&quot;;
        },
        getStr:function(){
            return name + &quot;:hello&quot;;
        }
    }
}
var builder = new createClosure();
builder.setStr();
console.log(builder.getStr()); //rose:hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的示例在函数中返回了两个闭包，这两个闭包都维持着对外部作用域的引用，因此不管在哪调用总是能够访问外部函数中的变量。在一个函数内部定义的函数，会将外部函数的活跃对象添加到自己的作用域链中，因此上面实例中通过内部函数能够访问外部函数的属性，这也是javascript模拟私有变量的一种方式。
请输入图片描述
注意：由于闭包会额外的附带函数的作用域（内部匿名函数携带外部函数的作用域），因此，闭包会比其它函数多占用些内存空间，过度的使用可能会导致内存占用的增加。&lt;/p&gt;

&lt;p&gt;闭包中的变量
在使用闭包时，由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function timeManage() {
        for (var i = 0; i &amp;lt; 5; i++) {
            setTimeout(function() {
                console.log(i);
            },1000)
        };
    }
    ```

上面的程序并没有按照我们预期的输入1-5的数字，而是5次全部输出了5。再来看一个示例：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;function createClosure(){
    var result = [];
    for (var i = 0; i &amp;lt; 5; i++) {
        result[i] = function(){
            return i;
        }
    }
    return result;
}
```&lt;/p&gt;

&lt;p&gt;调用createClosure()&lt;a href=&quot;&quot;&gt;0&lt;/a&gt;返回的是5，createClosure()&lt;a href=&quot;&quot;&gt;4&lt;/a&gt;返回值仍然是5。通过以上两个例子可以看出闭包在带有循环的内部函数使用时存在的问题：因为每个函数的作用域链中都保存着对外部函数（timeManage、createClosure）的活跃对象，因此，他们都引用着同一变量i，当外部函数返回值，此时的i值为5，因为内部的每个函数i的值为5。
那么如何解决这个问题呢？我们可以通过匿名包裹器（匿名自执行函数表达式）来强制返回预期的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function timeManage() {
    for (var i = 0; i &amp;lt; 5; i++) {
        (function(num) {
            setTimeout(function() {
                console.log(num);
            }, 1000);
        })(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在闭包匿名函数中再返回一个匿名函数赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function timeManage() {
    for (var i = 0; i &amp;lt; 10; i++) {
        setTimeout((function(e) {
            return function() {
                console.log(e);
            }
        })(i), 1000)
    }
}
//timeManager();输出1,2,3,4，5
function createClosure() {
    var result = [];
    for (var i = 0; i &amp;lt; 5; i++) {
        result[i] = function(num) {
            return function() {
                console.log(num);
            }
        }(i);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//createClosure()&lt;a href=&quot;&quot;&gt;1&lt;/a&gt;输出1；createClosure()&lt;a href=&quot;&quot;&gt;2&lt;/a&gt;输出2
无论是匿名包裹器还是通过嵌套匿名函数的方式，原理上都是由于函数是按值传递，因此会将变量i的值复制给实参num，在匿名函数的内部又创建了一个用于返回num的匿名函数，这样每个函数都有了一个num的副本，互不影响了。&lt;/p&gt;

&lt;p&gt;闭包中的this
在闭包中使用this时要特别注意，稍微不慎可能会引起问题。通常我们理解this对象是运行时基于函数绑定的，全局函数中this对象就是window对象，而当函数作为对象中的一个方法调用时，this等于这个对象（TODO 关于this做一次整理）。由于匿名函数的作用域是全局性的，因此闭包的this通常指向全局对象window：
&lt;code&gt;
var scope = &quot;global&quot;;
var object = {
    scope:&quot;local&quot;,
    getScope:function(){
        return function(){
            return this.scope;
        }
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;调用object.getScope()()返回值为global而不是我们预期的local，前面我们说过闭包中内部匿名函数会携带外部函数的作用域，那为什么没有取得外部函数的this呢？每个函数在被调用时，都会自动创建this和arguments，内部匿名函数在查找时，搜索到活跃对象中存在我们想要的变量，因此停止向外部函数中的查找，也就永远不可能直接访问外部函数中的变量了。总之，在闭包中函数作为某个对象的方法调用时，要特别注意，该方法内部匿名函数的this指向的是全局变量。
幸运的是我们可以很简单的解决这个问题，只需要把外部函数作用域的this存放到一个闭包能访问的变量里面即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scope = &quot;global&quot;;
var object = {
    scope:&quot;local&quot;,
    getScope:function(){
        var that = this;
        return function(){
            return that.scope;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;object.getScope()()返回值为local。&lt;/p&gt;

&lt;p&gt;内存与性能
由于闭包中包含与函数运行期上下文相同的作用域链引用，因此，会产生一定的负面作用，当函数中活跃对象和运行期上下文销毁时，由于必要仍存在对活跃对象的引用，导致活跃对象无法销毁，这意味着闭包比普通函数占用更多的内存空间，在IE浏览器下还可能会导致内存泄漏的问题，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; function bindEvent(){
    var target = document.getElementById(&quot;elem&quot;);
    target.onclick = function(){
        console.log(target.name);
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面例子中匿名函数对外部对象target产生一个引用，只要是匿名函数存在，这个引用就不会消失，外部函数的target对象也不会被销毁，这就产生了一个循环引用。解决方案是通过创建target.name副本减少对外部变量的循环引用以及手动重置对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  function bindEvent(){
    var target = document.getElementById(&quot;elem&quot;);
    var name = target.name;
    target.onclick = function(){
        console.log(name);
    }
    target = null;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;闭包中如果存在对外部变量的访问，无疑增加了标识符的查找路径，在一定的情况下，这也会造成性能方面的损失。解决此类问题的办法我们前面也曾提到过：尽量将外部变量存入到局部变量中，减少作用域链的查找长度。&lt;/p&gt;

&lt;p&gt;总结：闭包不是javascript独有的特性，但是在javascript中有其独特的表现形式，使用闭包我们可以在javascript中定义一些私有变量，甚至模仿出块级作用域，但闭包在使用过程中，存在的问题我们也需要了解，这样才能避免不必要问题的出现。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript 算出某值以内的质数</title>
   <link href="http://enml.github.io/blog/2011/01/12/prime"/>
   <updated>2011-01-12T00:00:00+08:00</updated>
   <id>http://enml.github.io/blog/2011/01/12/prime</id>
   <content type="html">&lt;h1&gt;javascript 算出某值以内的质数&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
    //算出 num 以内的所有质数
 
function prime(num){
    var list = [];
    for(var i = 2; i &lt;= num; i++){ list.push(i); } //create a Array
    
    for(var i = 0; i &lt; list.length; i++){
        for(var j = 2; j &lt; list[i]; j++){
            if(list[i] % j == 0){
                list.splice(i,1); //delete the non prime number.it will change the index of other elements
                j = 2; //由于splice导致list[i+1]的index变为i,因此把j置为2以便对list[i+1]进行重新计算
        }
    }
}
&lt;/pre&gt;

</content>
 </entry>
 
 
</feed>