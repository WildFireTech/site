<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>寂寞先生</title>
        <description>寂寞先生 - 陈佳伟</description>
        <link>http://enml.github.io/blog</link>
        <link>http://enml.github.io/blog</link>
        <lastBuildDate>2014-08-20T19:54:32+08:00</lastBuildDate>
        <pubDate>2014-08-20T19:54:32+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>canvas总结之图像处理</title>
                <description>&lt;h1&gt;canvas总结之图像处理&lt;/h1&gt;

&lt;hr /&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/24/canvas-image</link>
                <guid>http://enml.github.io/blog/2014/05/24/canvas-image</guid>
                <pubDate>2014-05-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>canvas总结之Pixel Manipulation</title>
                <description>&lt;h1&gt;canvas总结之Pixel Manipulation&lt;/h1&gt;

&lt;hr /&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/24/canvas-Pixel-Manipulation</link>
                <guid>http://enml.github.io/blog/2014/05/24/canvas-Pixel-Manipulation</guid>
                <pubDate>2014-05-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>canvas总结之动画</title>
                <description>&lt;h1&gt;canvas总结之动画&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt; &lt;pre class=&quot;prettyprint linenums&quot;&gt;
        function fallAnimation() {
            for (var i = 0; i &amp;lt; newBall.length; i++) {
                newBall[i].x += newBall[i].Vx;
                newBall[i].y += newBall[i].Vy;
                newBall[i].Vy += newBall[i].a;
                bounces();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            function bounces() {
                //反弹效果
                if (newBall[i].y &amp;gt;= (context.canvas.height - ball.radius)) {
                    newBall[i].y = (context.canvas.height - ball.radius);
                    newBall[i].Vy = -newBall[i].Vy * 0.75;
                }
                //delete the ball outside
                if (newBall[i].x + ball.radius &amp;lt; 0 || newBall[i].x - ball.radius &amp;gt; context.canvas.width) {
                    newBall.splice(i, 1);
                    i--;
                    console.log(newBall.length);
                }
                //停止interval当全部小球已滚出画面
                if (newBall.length == 0) {
                    clearInterval(start);
                }
            }
        }
    }

                    &amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/23/canvas_countdown</link>
                <guid>http://enml.github.io/blog/2014/05/23/canvas_countdown</guid>
                <pubDate>2014-05-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>canvas总结之method</title>
                <description>&lt;h1&gt;canvas总结之method&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2&gt;canvas介绍&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;canvas&lt;/code&gt;还没出现之前，开发人员通常使用 SVG，VML 等技术进行 Web 绘图操作，但这些基于XML的绘图语言声明式的绘图方式并不能满足复杂绘图操作在性能上的需求，特别是需要像素级别绘图能力的游戏。canvas提供了一系列用于绘图的API,我们可以使用JavaScript脚本语言在canvas中进行一系列基于命令的图形绘制操作。我们的绘图和动画终于可以摆脱第三方插件了，虽然前端的标准问题始终是个大坑。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;canvas id=&quot;canvas&quot;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/code&gt;  这就是canvas，它就是一个html标签，它除了提供一块画布和一系列的API让你可以在javascript中使用之外，看上去什么都没有。但是一块画布和一系列API就等于给了你一张纸和一套画图工具，你可以在上面发挥你的想象，至于画什么以及画的好不好那就是开发者功底的事了。接下来主要是对canvas的API进行分类和总结。&lt;/p&gt;

&lt;h2&gt;canvas的API&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Paths
 跟路径有关的method主要有：&lt;/li&gt;
&lt;li&gt;stroke()：画边框&lt;/li&gt;
&lt;li&gt;fill()：填充&lt;/li&gt;
&lt;li&gt;beginPath()：表示路径的开始&lt;/li&gt;
&lt;li&gt;closePath()：路径结束&lt;/li&gt;
&lt;li&gt;moveTo()：确定起点&lt;/li&gt;
&lt;li&gt;lineTo()：画直线&lt;/li&gt;
&lt;li&gt;arc()：画弧线，当然也能画圆&lt;/li&gt;
&lt;li&gt;rect()：画矩形&lt;/li&gt;
&lt;li&gt;bezierCurveTo()：贝塞尔曲线&lt;/li&gt;
&lt;li&gt;quadraticCurverTo()：二次方程曲线&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;我们通过下面的代码来看看实际效果。
&lt;code&gt;
    var canvas = document.getElementById(&quot;canvas&quot;),
        context = canvas.getContext(&quot;2d&quot;);
    context.beginPath();
    context.moveTo(20,20);
    context.lineTo(200,240);
    context.stroke();
    context.closePath();
&lt;/code&gt;
这是最简单的画线条方法，用moveTo()确定起点，再用lineTo()画线。有了线段我们可以干嘛？最直观的我们可以画几何图形，比如说三角形，矩形。当我们逻辑能力再强点，想象力再丰富点的时候，线段可以画出令人惊叹的画面。比如说下面的树，就是使用最简单的线段通过递归不断叠加画出来，因为通过random()函数对角度进行随机计算，因此你每一次刷新树的形状都会变化。&lt;/p&gt;

&lt;p&gt;2.style
    我们画出几何图形后，一切都是黑白的。这个时候需要的就是style相关的属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fillStyle：填充颜色&lt;/li&gt;
&lt;li&gt;strokeStyle：边框颜色&lt;/li&gt;
&lt;li&gt;shadowColor：阴影颜色&lt;/li&gt;
&lt;li&gt;shadowBlur：阴影虚化范围&lt;/li&gt;
&lt;li&gt;shadowOffsetX：阴影x轴偏移量&lt;/li&gt;
&lt;li&gt;shadowOffsetY：阴影y轴偏移量&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;`&quot;&gt;context.shadowBlur=10; 
context.shadowOffsetX=20; 
context.shadowColor=&quot;black&quot;; 
context.fillStyle=&quot;red&quot;; 
context.fillRect(20,20,100,80);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为矩形添加了黑色的阴影，阴影在x轴正方向偏移20px，阴影的虚化范围是10px。这几个canvas的style属性可以为图像添加漂亮的视觉效果，你的图像不再是水墨画，而是多彩多姿的水彩画。&lt;/p&gt;

&lt;p&gt;3.transition&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scale()：按比例放大缩小&lt;/li&gt;
&lt;li&gt;rotate()：旋转&lt;/li&gt;
&lt;li&gt;translate()：平移，会在原来的基础上平移&lt;/li&gt;
&lt;li&gt;transform()：变形&lt;/li&gt;
&lt;li&gt;setTransform()：重置原来的变形执行新的变形&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过transition的相关方法，我们可以把简单的几何图形旋转变形，因此我们不必为了要画另一个只需改变角度的新图形而从头开始，因为这样重复了大量的代码，不但耗时耗力，而且对于代码维护和性能优化都是一个隐患。这些method也可以使动画变得更简单。&lt;/p&gt;

&lt;p&gt;4.pixel manipulation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;createImageData()&lt;/li&gt;
&lt;li&gt;getImageData()&lt;/li&gt;
&lt;li&gt;putImageData()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这三个方法是从像素层次对图像进行操作，看上去很简单，但事实上功能很强大。我们可以获取图像的每一个像素，然后对像素进行操作，比如改变像素的rgb值，从而使整张图片得到完全不同的视觉效果，比如说对像素rgb值进行取反操作已实现整张图像反转滤镜效果。&lt;/p&gt;

&lt;p&gt;总结，今天介绍了canvas的主要绘图方法，这些方法基础功能很简单，但能实现极其惊艳的效果，具体就看自己能否把它用活。&lt;/p&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/21/canvas-method</link>
                <guid>http://enml.github.io/blog/2014/05/21/canvas-method</guid>
                <pubDate>2014-05-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>收藏颜色</title>
                <description>&lt;h1&gt;收藏颜色的工具&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://enml.github.io/blog/image/collect_color.jpg&quot; alt=&quot;collect_color&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用了三个小时完成了上图的功能，满足了我的需求。&lt;/p&gt;

&lt;p&gt;只要在输入框输入颜色数值，便可记录到数据库，并把颜色作为该数值背景色输出页面。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;本来是在寻找一个可以保存自己喜欢的颜色的工具，一开始想着记录在onenote，但是只能记录数值，不够直观。如果把图片粘贴过去会很繁琐并且不够雅观。后来把颜色直接合并在一张图上，但记录时每次都需要进行图片修改，繁琐也依然不美观。中午午睡后百度了一下是否有相关的在线工具，一无所获。突然想着要不自己搞一个吧！在脑海里构建了一下基本框架后觉得可行，便开始编写代码。花了三个小时总算实现了。&lt;/p&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/20/collect_color</link>
                <guid>http://enml.github.io/blog/2014/05/20/collect_color</guid>
                <pubDate>2014-05-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>HTTP协议的简析</title>
                <description>&lt;h1&gt;HTTP协议的简析&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;HTTP协议是一种可靠的数据传输协议，位于应用层，在TCP协议的上层。我们现在使用的web服务几乎都是建立在HTTP协议之上，HTTP是互联网通信的公共语言。&lt;/p&gt;

&lt;p&gt;从宏观角度来看，HTTP连接是一个很简单的过程，客户端发起请求，服务端相应响应的数据，断开连接。这就是一个完整的连接过程，我们每天上网都在经历这个过程，当你访问一个url时，浏览器会把这个url进行解析，通过dns获取域名对应的IP地址，然后向这个IP地址发送一个HTTP请求，告诉服务器我需要什么数据，服务器处理这个HTTP请求后调用对应的资源，给客户端一个HTTP响应，这个响应中就包含了我们请求的资源。&lt;/p&gt;

&lt;p&gt;上图是一个完整的HTTP连接过程。一般情况下请求中会包含3部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;start line(上图中的GET /something/some.gif HTTP/1.1)&lt;/li&gt;
&lt;li&gt;request header（键值对，比如Accept:text.*,用来告诉服务器我要接受的数据的格式是text）&lt;/li&gt;
&lt;li&gt;request body（get方法一般body为空，post方法会把提交给服务器的数据写在request body中）.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;同样服务器的respose中也会包含这三部分，但是内容不同。这里就不讲了。我们来讲数据的传输。&lt;/p&gt;

&lt;p&gt;HTTP是在应用层把我们的请求以及服务器的响应转化为&lt;code&gt;messages&lt;/code&gt;(报文)发送给传输层的TCP协议进行传输，也就是说，HTTP事实上并不关心数据的传输过程，数据传输依赖的是极为可靠的TCP协议。说到TCP，我们就不得不说&lt;code&gt;三次握手&lt;/code&gt;。TCP为了确保连接的可靠性，建立连接时必须遵循严格的三次握手确认才能连接成功。下图是示意图：&lt;/p&gt;

&lt;p&gt;我尽可能用通俗的语言来讲解这个过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一次握手：client把自己的身份证（SYN）发给server，告诉server说我要跟你连接。&lt;/li&gt;
&lt;li&gt;第二次握手：server知道client想跟他连接后，就在收到的client的身份证上盖个章（ACK=SYN+1），然后把server自己的身份证(新的SYN)+盖了章的身份证一起发回给client，告诉他我同意你的连接请求。&lt;/li&gt;
&lt;li&gt;第三次握手：client看到自己的身份证已经盖了章，就相信这个请求确实是来自server并且server同意连接，所以client也在server的身份证上盖个章（新ACK=新SYN+1）发回给server。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;server收到自己的盖了章的身份证后就跟client建立连接，发送数据。现在的TCP栈都运行客户端在第三次握手时直接把&lt;code&gt;messages&lt;/code&gt;发送给服务器。为什么要三次握手，而不是两次呢？据我目前的理解，三次握手是已最低的代价来保证数据传输的可靠性。我们假设只有两次握手即可建立连接发送数据，那么如果在第二次握手的过程中确认包丢失，client端收不到server的确认包，那么client会认为他们之间还不能建立连接，而server并不知道确认包丢失了，以为我已经确认了我们就可以建立连接，所以此时server就会跟client进行通信，但client肯定会拒收，server就一直重发数据，造成了一个死结。而很明显，三次握手就不会出现这种不可靠的情况，四次握手就更可靠了，但浪费资源。&lt;/p&gt;

&lt;p&gt;说完TCP建立连接的过程，我们再回过头来看一看HTTP报文是怎么传输的。下图所示&lt;/p&gt;

&lt;p&gt;这是报文传输的过程，浏览器解析用户请求==&gt;生成HTTP请求报文==&gt;TCP三次握手跟服务器建立连接==&gt;传送报文给服务器==&gt;服务器处理报文请求，生成HTTP响应报文==&gt;传送报文给客户端==&gt;断开连接。&lt;/p&gt;

&lt;p&gt;我们对HTTP请求已经数据传输的过程有了大概的了解之后，我们再来谈谈一些HTTP报文的细节，关于状态码、请求方法。&lt;/p&gt;

&lt;h3&gt;状态码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;100-199 ：信息提示&lt;/li&gt;
&lt;li&gt;200-299：成功&lt;/li&gt;
&lt;li&gt;300-399：重定向&lt;/li&gt;
&lt;li&gt;400-499：客户端错误&lt;/li&gt;
&lt;li&gt;500-599：服务器错误&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其中我们挑出几个常用的具有代表性的说一下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;100 continue&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这是一个比较让人疑惑的状态码。它向服务器发送一个携带了值为100 continue的expect请求，服务器收到后响应一个100 continue状态码或者错误码。这看上去很多余，但事实上，的确有那么点多余，但是它有一个作用就是在发送实体之前先确认服务器是否接受这个实体，避免发送了一个服务器无法处理或使用的实体。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;200 ok&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这个最常见，你每一个成功的请求都会收到200 ok的状态码，告诉浏览器请求成功。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;304 no modified&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以在请求里添加If-Modefied-Since:xxx的首部，服务器对请求资源进行检验后若确定在该时间内资源未被改动，则可以返回304 no modefied进行资源重定向，让浏览器直接使用本地副本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;404 not found&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当服务器无法找到你所请求的资源，可能资源已不存在，可能客户端的请求有错误，这时候会返回404 not found，这个几乎每个上网的用户都会遇到。&lt;/p&gt;

&lt;p&gt;上面是比较常见的状态码的含义。在HTTP报文里面，状态码是一种很重要的信息，为客户端提供了一种理解事务处理结果的便捷方式。&lt;/p&gt;

&lt;p&gt;下一篇文章会归纳关于HTTP报文通过TCP/IP底层协议进行传输的性能问题。&lt;/p&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/20/HTTP</link>
                <guid>http://enml.github.io/blog/2014/05/20/HTTP</guid>
                <pubDate>2014-05-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Template</title>
                <description>&lt;h1&gt;Template&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;在view里面，我们获取了相关的数据，但我们的目的是将数据呈现出来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.首先我们想到的是直接把数据硬编码到html代码里面，然后通过&lt;code&gt;HttpResponse&lt;/code&gt;对象传递给浏览器进行渲染：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % now
    return HttpResponse(html)
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;但是很明显这种方法不适合生产环境，你不可能把整个html页面都硬编码在view里面，因为这显得既愚蠢又低效。对于template的改动很明显要比view频繁得多，这种方式意味着你想更改页面表现时都必须得改动python代码，并且前后端无法同步开发。于是有了第二种方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.把html代码分离成独立的模板，通过加载模板文件进行渲染，这样可以实现前后端分离：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;   #view
from django.shortcuts import render_to_response
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response(&#39;current_datetime.html&#39;, {&#39;current_date&#39;: now})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#template
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now .&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过render()传递数据给template的方式在上一篇文章有列举出来。这种模式的好处很明显。但我们又遇到一个问题：&lt;strong&gt;假如我的网站有100个页面，那我是不是要写100个template呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道这样是愚蠢。编程中有一个很重要的思想就是--&lt;strong&gt;最大限度地实现代码重用。&lt;/strong&gt; 而我们写100个页面的重复代码可能已经超过40%了，这不但费时费力，你还可能见笑于大方之家。所以我们有一种优雅的解决方式：&lt;strong&gt;include&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1). 把重用代码分离出来，比如header.html,footer.html,sidebar.html；然后&lt;code&gt;include&lt;/code&gt;到content.html中。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# header.html

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # footer.html

        &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# include &#39;header&#39; and &#39;footer&#39;

{ include &#39;header.html&#39; %}
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
{ include &#39;footer.html&#39; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，这样很优雅，可以实现代码重用。但是仍然有个问题：当代码中存在哪怕一个标记不同时，这部分代码你就无法分离出来，这导致了你仍然需要重复大量的代码。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# first page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;The current time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# second page

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Future time&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;

    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个页面中&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;不同，意味着&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;以下的部分都不能并入&lt;code&gt;header.html&lt;/code&gt;中，哪怕下面仍然存在大量的重复代码。所以有了更优雅的解决办法：&lt;strong&gt;extends&lt;/strong&gt; -- inculde的逆向思维。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2). 我们把模板里面的‘不同代码’进行定义，相同的代码保存为base模板&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;{ block title %}{ endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;My helpful timestamp site&amp;lt;/h1&amp;gt;
    { block content %}{ endblock %}
    { block footer %}
    &amp;lt;hr&amp;gt;
    &amp;lt;p&amp;gt;Thanks for visiting my site.&amp;lt;/p&amp;gt;
    { endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;base.html&lt;/code&gt;变成了一个骨架，你可以把需要的内容填充进去即可，这最大限度实现了代码重用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # first page

    { extends &quot;base.html&quot; %}

    { block title %}The current time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;It is now .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    # second page

    { extends &quot;base.html&quot; %}

    { block title %}Future time{ endblock %}

    { block content %}
    &amp;lt;p&amp;gt;In  hour(s), it will be .&amp;lt;/p&amp;gt;
    { endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;woo! 简单优雅！这是Template设计的思想历程。&lt;/p&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/10/template</link>
                <guid>http://enml.github.io/blog/2014/05/10/template</guid>
                <pubDate>2014-05-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>view传递context的方式</title>
                <description>&lt;h1&gt;view传递context的方式&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt; 通过view的render()方法填充template可以有以下方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.适合于数据量小且静态的数据。在template中直接使用相关键值为标签：
&lt;code&gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test1(request):
    return render(request,&#39;test/raw.htm&#39;,{
                &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False})
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;p&gt;2.通过调用属性的方式传递整个dictionary。但在template中必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test2():
    person = {  &#39;name&#39;:&#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,{ &#39;person&#39;:person, &#39;dict&#39;:dict})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.使用&lt;strong&gt;locals(),locals()&lt;/strong&gt; 是个字典，直接赋值给变量。很明显这种方式更加优雅和便捷，但缺点就是它会把所有的dictionary都传递，也就是说它默认传递的值可能会比你预想中的多。&lt;/p&gt;

&lt;p&gt;   template中仍然必须使用属性方式：{{ &lt;strong&gt;person.&lt;/strong&gt; name }},{\% for i,k in &lt;strong&gt;dict.&lt;/strong&gt; items \%}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def test3():
    person = {  &#39;name&#39;: &#39;Enm&#39;,
                &#39;age&#39;:22,
                &#39;company&#39;: &#39;Outdoor Equipment&#39;,
                &#39;ship_date&#39;: datetime.datetime.now(),
                &#39;ordered_warranty&#39;: False}

    dict = {&quot;name&quot;:&quot;enm&quot;,&quot;age&quot;:&quot;21&quot;,&quot;school&quot;:&quot;szu&quot;}
    return render(request,&#39;test/raw.htm&#39;,locals())
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://enml.github.io/blog/2014/05/03/view_render</link>
                <guid>http://enml.github.io/blog/2014/05/03/view_render</guid>
                <pubDate>2014-05-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>install jekyll 流程</title>
                <description>&lt;h1&gt;install jekyll 流程&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先下载&lt;code&gt;ruby&lt;/code&gt;&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;安装ruby download&lt;/a&gt; ，然后下载&lt;strong&gt;DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe&lt;/strong&gt;。安装完&lt;code&gt;ruby&lt;/code&gt;后，再安装&lt;code&gt;rubyGems&lt;/code&gt;:运行&lt;code&gt;gem update --system&lt;/code&gt;即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压DevKit，然后命令行cd到该目录，运行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;pre&gt;&lt;code&gt; ruby dk.rb init
 ruby dk.rb review 
 ruby dk.rb install
 gem install rdiscount --platform=ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DevKit安装完后，即可安装jekyll：&lt;code&gt;gem install jekyll&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://enml.github.io/blog/2014/04/27/install-jekyll</link>
                <guid>http://enml.github.io/blog/2014/04/27/install-jekyll</guid>
                <pubDate>2014-04-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>python list的技巧</title>
                <description>&lt;h1&gt;Python list的一些技巧&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;列表相邻元素压缩器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; zip(*([iter(a)] * 2))
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::2], a[1::2])
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; zip(a[::3], a[1::3], a[2::3])
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*(a[i::k] for i in range(k)))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;用压缩器反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m.items()
[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]
&amp;gt;&amp;gt;&amp;gt; zip(m.values(), m.keys())
[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]
&amp;gt;&amp;gt;&amp;gt; mi = dict(zip(m.values(), m.keys()))
&amp;gt;&amp;gt;&amp;gt; mi
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表展开&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2], [3, 4], [5, 6]]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain.from_iterable(a))
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; sum(a, [])
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; [x for l in a for x in l]
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; [x for l1 in a for l2 in l1 for x in l2]
[1, 2, 3, 4, 5, 6, 7, 8]

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
&amp;gt;&amp;gt;&amp;gt; flatten(a)
[1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;生成器表达式&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; g = (x ** 2 for x in xrange(10))
&amp;gt;&amp;gt;&amp;gt; next(g)
0
&amp;gt;&amp;gt;&amp;gt; next(g)
1
&amp;gt;&amp;gt;&amp;gt; next(g)
4
&amp;gt;&amp;gt;&amp;gt; next(g)
9
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10))
2025
&amp;gt;&amp;gt;&amp;gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)
408
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;字典推导&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {x: x ** 2 for x in range(5)}
&amp;gt;&amp;gt;&amp;gt; m
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; m = {x: &#39;A&#39; + str(x) for x in range(10)}
&amp;gt;&amp;gt;&amp;gt; m
{0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用字典推导反转字典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m
{&#39;d&#39;: 4, &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&amp;gt;&amp;gt;&amp;gt; {v: k for k, v in m.items()}
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Point = collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p
Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; p.x
1.0
&amp;gt;&amp;gt;&amp;gt; p.y
2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;继承命名元组&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Point(collections.namedtuple(&#39;PointBase&#39;, [&#39;x&#39;, &#39;y&#39;])):
...     __slots__ = ()
...     def __add__(self, other):
...             return Point(x=self.x + other.x, y=self.y + other.y)
...
&amp;gt;&amp;gt;&amp;gt; p = Point(x=1.0, y=2.0)
&amp;gt;&amp;gt;&amp;gt; q = Point(x=2.0, y=3.0)
&amp;gt;&amp;gt;&amp;gt; p + q
Point(x=3.0, y=5.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有最大长度的双端队列&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; last_three = collections.deque(maxlen=3)
&amp;gt;&amp;gt;&amp;gt; for i in xrange(10):
...     last_three.append(i)
...     print &#39;, &#39;.join(str(x) for x in last_three)
...
0
0, 1
0, 1, 2
1, 2, 3
2, 3, 4
3, 4, 5
4, 5, 6
5, 6, 7
6, 7, 8
7, 8, 9
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可排序词典&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = dict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
1, 0, 3, 2, 5, 4, 7, 6, 9, 8
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
&amp;gt;&amp;gt;&amp;gt; m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))
&amp;gt;&amp;gt;&amp;gt; print &#39;, &#39;.join(m.keys())
10, 9, 8, 7, 6, 5, 4, 3, 2, 1
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://enml.github.io/blog/2014/04/25/python-code</link>
                <guid>http://enml.github.io/blog/2014/04/25/python-code</guid>
                <pubDate>2014-04-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jekyll加载图片的路径问题</title>
                <description>&lt;h1&gt;jekyll加载图片的路径问题&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　一开始使用根目录&lt;code&gt;/assets/…/img/bg.png&lt;/code&gt;的方式，在localhost调试成功，但在github pages失败。
　后来试了一下当前目录方式&lt;code&gt;./img/bg.png&lt;/code&gt;成功。也可以用&lt;code&gt;img/bg.png&lt;/code&gt;表示当前目录。&lt;/p&gt;

&lt;!--break--&gt;

</description>
                <link>http://enml.github.io/blog/2014/04/24/directory</link>
                <guid>http://enml.github.io/blog/2014/04/24/directory</guid>
                <pubDate>2014-04-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>对5天来关于jekyll的心得</title>
                <description>&lt;h1&gt;完成基于jekyll的第一个blog&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　今天差不多把blog完成了，这是我第一个基于jekyll的blog，定制了主题，修改了相关配置，以及解决了中文bug。现在把这5天的心得分享一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先是中文问题，这个困扰我了很久，也花费了不少时间，不过最后总算找到解决办法。给我最大的感触就是，即使碰壁，也得硬着头皮找下去，如果放弃，那就前功尽弃了。&lt;/li&gt;
&lt;/ul&gt;


&lt;!--break--&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后是关于bootstrap，因为主题是基于bootstrap，所以这几天对bootstrap也有了深入的了解。Less预编译的思想其实挺方便的，只不过先前习惯了直接div+css的方式后一时难以习惯，但是，习惯是用来打破，不打破那永远都进不了步。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@media通过检测min-width和max-width来进行响应式布局，但要编写全局css时要注意，否则很容易响应不了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\&lt;hr&gt; 添加个具有margin的hr，然后在使用card style时可以通过添加hr来达到分割的效果。另一种方式是直接为card添加一个margin-top。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当我使用中文的categories时，由于permalink中包含categories，导致链接失败。所以只要到_config.yml中修改permalink即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://enml.github.io/blog/2014/04/23/finish-jekyll</link>
                <guid>http://enml.github.io/blog/2014/04/23/finish-jekyll</guid>
                <pubDate>2014-04-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>解决invalid byte sequence in GBK</title>
                <description>&lt;h1&gt;解决invalid byte sequence in GBK&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;　jekyll对中文的支持不太好，导致经常出现乱码甚至无法运行&lt;code&gt;jekyll server&lt;/code&gt;命令。解决post内容乱码问题可以通过修改convertible.rb文件的第27行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.content = File.read(File.join(base, name), :encoding =&amp;gt; &quot;utf-8&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　原因File.read()可能采用系统默认编码读取文件，中文系统为GBK，但markdown文件均为utf-8编码，所以导致无法正确展现中文。&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　但是当我在post.html模板里面加入中文之后，&lt;code&gt;jekyll server&lt;/code&gt;命令直接报错。解决办法是在运行服务器前先运行&lt;code&gt;chcp 65001&lt;/code&gt;命令，即可解决。在官方找到的解决办法&lt;strong&gt;Windows users: run chcp 65001 first to change the command prompt&#39;s character encoding (code page) to UTF-8 so Jekyll runs without errors.&lt;/strong&gt;&lt;/p&gt;
</description>
                <link>http://enml.github.io/blog/2014/04/23/chinese-messy-code</link>
                <guid>http://enml.github.io/blog/2014/04/23/chinese-messy-code</guid>
                <pubDate>2014-04-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>后智能手机时代</title>
                <description>&lt;h1&gt;谁将取代智能手机&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wccbr.com/wp-content/uploads/2013/03/Robot_Wallpaper_1.jpg&quot; alt=&quot;robot&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能手表&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　现在手表被炒的很热，但以目前来看，手表只是一个辅佐设备；注定手表不可能超越智能手机。手表的特点在于屏幕小，便携，查看信息快速直接；但屏幕小也是它的极限性（屏幕扩大了跟智能手机就没差别了），决定了它不适合发展成独立的终端，你能想象拿着手表刷微博看知乎发邮件吗？&lt;/p&gt;

&lt;!--break--&gt;


&lt;p&gt;　除非发展出了超越平面显示的信息展现方式，比如说已经被说烂了的“全息投影”。否则手表永远只能是手机的辅佐设备。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;智能眼镜&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这货一开始我不看好，谁tm想戴个电池cpu在太阳穴那里，而且带了几年眼镜的我表示对眼镜深痛恶绝啊。后来了解了google glass之后，我发现这货绝对是未来。不，我是说这个方向。&lt;/p&gt;

&lt;p&gt;　为什么智能眼镜有潜力取代智能手机呢？首先，我们从电子设备的发展历程可以看出，任何具有划时代的产品都是通过对人机交互方式进行革新。从命令行跨越到图形界面，从物理按键跨越到触摸，从遥控器跨越到体感声控……再看看手表，再怎么有想象力它始终只是一部小尺寸精简化的手机绑在手上，不管是现在市面上丑陋不堪的炒作产品，还是被寄予厚望的iwatch，都难以在信息展现方式上得到突破；再看看眼镜，信息是直接投射到视网膜上，信息展现方式已经不再局限于屏幕的大小，你眼前的整个视角都是屏幕，甚至可以通过调节投射的焦距而达到调节屏幕的大小，那可想像的空间可就大了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为展现信息独特的视角，眼镜可以覆盖你的整个视角，它可以挡住外来的光线让你完全沉浸在数字光影之中；你可以随时随地享受不亚于甚至超越IMAX的视觉盛宴。是的，我说的不是3D眼镜。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为现实与虚拟的无缝结合，你去超市或者在复杂的商业街寻找餐馆，你不用再打开地图或者大众点评，你眼前就是信息与现实的结合体；如果你用过nokia的city lens，你一定知道我在说什么。你不用再厚着脸皮去找心仪的妹子要联系方式了，只要她在社交网络公开信息，你盯着她看几秒可能就已经加了她的微信或者facebook了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为“所见即所得”，你所能看到的美景都可以收入囊中，不会再因为掏出手机解锁打开相机应用而错过稍众即逝的美景。当然，google glass现在因为这个产生的隐私问题而备受争议。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;……还有很大的想象空间，只是我想不出来了。但是如果做到以上3点，你完全可以抛弃你的智能机了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　以上，并不是空穴来风的天方夜谭，不信，你试着在手表上想象一下。这些是基于信息展现方式，或者说是交互方式的革新。google glass目前并不足以产生颠覆性，产品还不完善，技术也难以突破，生态更是一片荒芜，但它叩开了一个全新世界的大门，这个大门后面的世界才是未来。说实话，我更期待苹果和微软在这方面的突破。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;机器人&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　这条路任重而道远，真的要发展出人工智能的话，很可能要对现有的计算机体系、软硬架构、甚至编程思想统统进行颠覆才有可能。但是，100年后每个人身边陪着个高度智能的机器人作助手甚至伴侣应该没什么好争议的。那时候什么手机电脑手表眼镜通通可以扔掉了，人可以真正得到解放，这个随时随地跟着你的机器人就是你最好最强大的电子设备了。你要打电话，你就跟它说帮我call一下奥巴马；你要玩游戏，它转过身来可能后背就是一块触摸屏；你要写代码，哦，那时候应该不用写代码了……&lt;/p&gt;
</description>
                <link>http://enml.github.io/blog/2014/04/21/future</link>
                <guid>http://enml.github.io/blog/2014/04/21/future</guid>
                <pubDate>2014-04-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>js-算出某值以内的质数</title>
                <description>&lt;h1&gt;js 算出某值以内的质数&lt;/h1&gt;

&lt;hr /&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
    //算出 num 以内的所有质数
 
function prime(num){
    var list = [];
    for(var i = 2; i &lt;= num; i++){ list.push(i); } //create a Array
    
    for(var i = 0; i &lt; list.length; i++){
        for(var j = 2; j &lt; list[i]; j++){
            if(list[i] % j == 0){
                list.splice(i,1); //delete the non prime number.it will change the index of other elements
                j = 2; //由于splice导致list[i+1]的index变为i,因此把j置为2以便对list[i+1]进行重新计算
        }
    }
}
&lt;/pre&gt;

</description>
                <link>http://enml.github.io/blog/2011/01/12/prime</link>
                <guid>http://enml.github.io/blog/2011/01/12/prime</guid>
                <pubDate>2011-01-12T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
